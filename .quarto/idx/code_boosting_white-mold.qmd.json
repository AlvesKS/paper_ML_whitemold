{"title":"XgBoost model","markdown":{"yaml":{"title":"XgBoost model"},"headingText":"Libraries","containsRefs":false,"markdown":"\n\n\n::: callout-warning\n# About R packages\n\nMake sure to have all R packages installed before running the analysis described in this website.\n:::\n\n```{r message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(SHAPforxgboost)\nlibrary(cowplot)\nlibrary(lemon)\nlibrary(ggthemes)\nlibrary(ggdist)\nlibrary(patchwork)\nlibrary(rgr)\nlibrary(vip)\nlibrary(pdp)\nlibrary(doParallel)\n\ntheme_set(theme_half_open(font_size = 12))\n```\n\n```{r eval=TRUE, include=FALSE}\nlibrary(knitr)\n\nknit_print.data.frame <- function (x, options, ...) {\n  rmarkdown::paged_table(x, options) %>% \n    rmarkdown:::print.paged_df()\n}\n\nregisterS3method(\"knit_print\", \"data.frame\", knit_print.data.frame)\n```\n\n## Data Fusion\n\n### Load white mold data\n\n```{r}\nwm_load = read.csv(\"data_white-mold/data_model_plus_weather_filtered.csv\")\nwm_load\n```\n\n#### Wragling\n\n```{r}\nwm_data = wm_load %>%\n  #transform these columns into Date format\n  mutate(date = as.Date(date),\n         sampling.date =  as.Date(sampling.date),\n         planting.date = as.Date(planting.date)) %>% \n  \n  # Calculate dap\n  mutate(dap = date-planting.date) %>% \n  # #\n  # # mutate(gddi = ((t2m_max +t2m_min)*0.5)-0) %>%\n  # group_by(subject) %>% \n  # mutate(gdd = cumsum(gddi)) %>% \n  \n  group_by(subject) %>% \n  mutate(wm = (mean(wm, na.rm =T)>0)*1) %>% \n  ungroup() %>% \n  filter(!is.na(wm))\n  \n  \nwm_data\n```\n\n### Functional data analysis data\n\n```{r}\nwhite_load_fda = read.csv(\"data_white-mold/data_fda_sig_diff.csv\") %>% \n  filter(dap<=50,\n         dap>=-15)%>% \n  separate(var, into =c(\"var\", \"stats\"), sep =\"_\") %>% \n  mutate(var = toupper(var)\n         # stats = ifelse(is.na(stats),\"\",stats)\n         ) %>% \n  unite(var,var, stats, sep = \" \", na.rm = T) %>% \n  mutate(sig_diff = case_when(var == \"RH\" & dap %in% c(40:50) ~ TRUE,\n                              TRUE ~ sig_diff)) %>% \n  filter(var != \"DPD\")\n\nvar_names = unique(white_load_fda$var)\n```\n\n-   Defining periods\n\nThis function define and name the periods that the functional curves significatively difered from zero or not.\n\n```{r}\ndefine_interval = function(variable, data){\n\ntest_df = data  %>%\n  filter(var == variable ) %>%\n  group_by(subject,var, wm) %>% \n  mutate(sig_diff = sig_diff*1) \n\n\nperiod = numeric(length(-15:50))\nperiod_all = numeric( length(-15:50)*length(unique(test_df$subject)) )\n\ninter = 1:66\nfor(j in unique(test_df$subject)){\n  \n per = 1 \n \n filt_df = test_df %>% \n      filter(subject == j)\n \n  # current = filt_df$sig_diff[1]\n  period[1]= per\n  \n  for(i in 1:(length(-15:49))){\n  \n   if(filt_df$sig_diff[i+1] == filt_df$sig_diff[i]){\n    per = per\n   }else{\n    per = per+1\n  }\n  \n  period[i+1]= per\n  \n\n  }\n period_all[inter] =period\n inter = inter+66\n}\noptions(dplyr.summarise.inform = FALSE)\nfinal_df = test_df %>%\n  ungroup() %>% \n  mutate(periodo = period_all*sig_diff) %>% \n  group_by(subject, wm, periodo) %>%\n  filter(periodo !=0) %>% \n  mutate(per_name = paste0(\"(\",min(dap),\" to \", max(dap), \" dap)\")) %>%\n  group_by(subject,per_name, wm) %>%\n  summarise(x = mean(value)) %>%\n  pivot_wider(values_from = `x`,\n              names_from = per_name, \n              names_prefix = paste(variable,\" \"))\n\nreturn(final_df)\n\n}\n\ndata_fda_list = lapply(var_names,define_interval, data =  white_load_fda)\nmerged_fda =  Reduce(function(...) merge(..., all=T), data_fda_list) \n```\n\n### Soil data\n\n\n```{r}\nsoil_df_load =read.csv(\"soil_images/extracted_soil_data.csv\") %>% \n  dplyr::select(-longitude, -latitude)\n```\n\n-   Centered log-ratio transformation for sand, silt, and clay\n\n```{r}\nsoil_comp = as.matrix(soil_df_load[c(\"clay\",\"sand\",\"silt\")])\n\nlog_sand_clay = log(soil_comp[,\"sand\"]/soil_comp[,\"clay\"])\nlog_silt_clay = log(soil_comp[,\"silt\"]/soil_comp[,\"clay\"])\n\ntexture =  data.frame(log_sand_clay, log_silt_clay)\n```\n\n\n```{r}\nsoil_df_load %>% \n  bind_cols(texture) %>% \n  filter(clay<30) %>% \n  ggplot(aes(clay,log_silt_clay , color =silt))+\n  geom_point()+\n  geom_hline(yintercept = c(1.1,1.3))+\n  scale_color_gradient(low =\"#1e88e5ff\",\n                       high = \"#ff0d57ff\",\n                       n.breaks = 5,\n                       guide = guide_colorbar(barwidth = 10,\n                                              barheight = 0.3))+\n  labs(color = \"Silt (%)\",\n       y = \"log(Silt/Clay)\",\n       x = \"Clay (%)\")+\n  theme(legend.position = \"top\")+\n  \n\n\n\nsoil_df_load %>% \n  bind_cols(texture) %>% \n  filter(clay<30) %>% \n  ggplot(aes(clay,log_sand_clay , color =sand))+\n  geom_point()+\n  scale_color_gradient(low =\"#1e88e5ff\",\n                       high = \"#ff0d57ff\",\n                       n.breaks = 5,\n                       guide = guide_colorbar(barwidth = 10,\n                                              barheight = 0.3))+\n  labs(color = \"Sand (%)\",\n       y = \"log(Sand/Clay)\",\n       x = \"Clay (%)\")+\n  theme(legend.position = \"top\")+\n  \n  plot_annotation(tag_levels = \"A\")\n  \n```\n\n\n\n\n```{r}\nsoil_df = soil_df_load %>% \n  dplyr::select(-sand, -silt, -clay) %>% \n  bind_cols(texture)\n\n```\n\n\n\n```{r}\ntidy_soil_df = soil_df %>% \n  full_join(merged_fda[c(\"subject\", \"wm\")]) %>% \n  filter(!is.na(wm)) %>% \n  dplyr::select(-subject, -hb,-n, -alpha,-lambda, -ksat) %>%  \n  pivot_longer(1:7, \n               names_to = \"variable\",\n               values_to = \"values\") %>%\n  mutate(variable = case_when(variable == \"theta_r\" ~ \"Residual soil water content (m³/m³)\",\n                              variable == \"theta_s\" ~ \"Saturated soil water content (m³/m³)\",\n                              variable == \"om\" ~ \"Soil organic matter (%)\",\n                              variable == \"ph\" ~ \"Soil pH\",\n                              variable == \"bd\" ~ \"Soil bulk density g/cm³\",\n                              variable == \"log_sand_clay\" ~ \"log(Sand/Clay)\",\n                              variable == \"log_silt_clay\" ~ \"log(Silt/Clay)\"))\n```\n\n\n```{r}\ntidy_soil_df %>% \n  ggplot(aes(as.factor(wm), values, color = values))+\n  ggforce::geom_sina(\n    alpha = 0.8,\n    color = \"gray\",\n    maxwidth =0.5\n    )+\n  geom_boxplot(\n    fill = NA,\n    outlier.colour = NA,\n    width =0.5,\n    color = \"black\"\n    )+\n  facet_rep_wrap(\n    ~variable,\n    scales = \"free_y\",\n    ncol = 2,\n    strip.position = \"left\",\n    labeller = label_wrap_gen(width=20)\n    )+\n  scale_x_discrete(labels = c(\"1\" = \"Prevalent\",\n                              \"0\" = \"Non-prevalent\" ))+\n  labs(x = \"White mold prevalence\",\n       y = \"\")+\n  theme(\n    strip.background = element_blank(),\n    strip.placement = \"outside\",\n    axis.text = element_text(size=7)\n    )\n\n\n# ggsave(\"figs/xboost_figs/soil_data.png\", dpi = 900, height = 7, width = 6, bg = \"white\")  \n```\n\n\n\n<!-- ```{r} -->\n<!-- soil_df_selec= soil_df %>%  -->\n<!--   dplyr::select(-subject, -hb,-n, -alpha,-lambda, -ksat)  -->\n\n<!-- corr <- round(cor(soil_df_selec), 1) -->\n<!-- p.mat <- ggcorrplot::cor_pmat(soil_df_selec) -->\n\n<!-- ggcorrplot::ggcorrplot(corr,  -->\n<!--                        hc.order = TRUE, -->\n<!--                        type = \"lower\", -->\n<!--                        p.mat = p.mat, -->\n<!--                        lab = TRUE) -->\n<!-- ``` -->\n\n\n\n### Data from original dataset\n\n```{r}\nwm_original = wm_data %>% \n  group_by(subject) %>% \n  summarise(elevation = unique(elevation),\n            `Planting date` = format(mean(planting.date), \"%j\"))\n```\n\n\n\n\n\n\n\n### Fusioning datasets\n\n```{r}\nml_data_fda =soil_df %>%\n  full_join(merged_fda) %>% \n  full_join(wm_original) %>% \n  filter(!is.na(wm)) %>% \n  mutate(wm= factor(wm, levels =c(\"1\", \"0\")),\n         `Planting date` = as.numeric(`Planting date`)) %>%\n  ungroup() %>% \n  dplyr::select(-subject, -hb,-n, -alpha,-lambda, -ksat) %>% \n  relocate(wm)\n\n\nwrite.csv(ml_data_fda, \"data_white-mold/data_tidy_xgboost.csv\", row.names = F)\n```\n\n## XGboost modeling\n\n-   setting up parallel computation\n\n```{r}\nlibrary(parallel)\nall_cores <- parallel::detectCores(logical = FALSE)\nregisterDoParallel(cores = all_cores)\n```\n\n-   Preprocessing\n\n```{r}\npreprocessing_recipe <- \n  recipes::recipe(wm ~ ., data = ml_data_fda) %>%\n  # convert categorical variables to factors\n  recipes::step_string2factor(all_nominal()) %>%\n  # combine low frequency factor levels\n  recipes::step_other(all_nominal(), threshold = 0.01) %>%\n  # remove no variance predictors which provide no predictive information \n  recipes::step_nzv(all_nominal()) %>%\n  prep()\n```\n\n-   Splitting for Cross Validation\n\n```{r}\names_cv_folds <- \n  recipes::bake(\n    preprocessing_recipe, \n    new_data = ml_data_fda#training(wm_split)\n  ) %>%  \n  rsample::vfold_cv(v = 5)\n```\n\n-   XGBoost Model Specification\n\n```{r}\nxgboost_model <- \n  parsnip::boost_tree(\n    mode = \"classification\",\n    trees = 5000,\n    min_n = tune(),\n    tree_depth = tune(),\n    mtry = tune(),#<<<<<<<<<\n    learn_rate = tune(),\n    loss_reduction = tune()\n  ) %>%\n    set_engine(\"xgboost\")\n```\n\n-   Grid Specification\n\n```{r}\nxgboost_params <- \n  dials::parameters(\n    min_n(),\n    finalize(mtry(), ml_data_fda),#<<<<<<<<<\n    tree_depth(range = c(1L, 5L)),\n    learn_rate(),\n    loss_reduction()\n  )\nset.seed(1)\n\nxgboost_grid <- \n  dials::grid_max_entropy(\n    xgboost_params, \n    size = 60\n  )\nhead(xgboost_grid)\n```\n\n-   Define the Workflow\n\n```{r}\nxgboost_wf <- \n  workflows::workflow() %>%\n  add_model(xgboost_model) %>% \n  add_formula(wm ~ .)\n```\n\n### Tune the Model\n\n[metrics](https://yardstick.tidymodels.org/articles/metric-types.html)\n\n```{r eval=FALSE, include=T}\nxgboost_tuned_fda <- tune::tune_grid(\n  object = xgboost_wf,\n  resamples = ames_cv_folds,\n  grid = xgboost_grid,\n  metrics = yardstick::metric_set(recall, precision, f_meas,accuracy, kap,roc_auc, sens, spec,mn_log_loss),\n  control = tune::control_grid(verbose = TRUE, save_pred = TRUE)\n)\n# ml_data\nsaveRDS(xgboost_tuned_fda, \"xgboost/tuned_grid_fda.RDS\")\n```\n\n```{r include=FALSE}\nxgboost_tuned_fda = readRDS(\"xgboost/tuned_grid_fda.RDS\")\n```\n\n```{r}\nxgboost_tuned_fda %>% \n  collect_metrics()%>%\n  filter(.metric == \"accuracy\") %>%\n  dplyr::select(mean, mtry:loss_reduction) %>%\n  pivot_longer(mtry:loss_reduction,\n               values_to = \"value\",\n               names_to = \"parameter\"\n  ) %>%\n  ggplot(aes(value, mean, color = parameter)) +\n  geom_point(alpha = 0.8, show.legend = FALSE) +\n  facet_wrap(~parameter, scales = \"free_x\") +\n  labs(x = NULL, y = \"accuracy\")\n```\n\n### Best model\n\n```{r}\nxgboost_best_params <- xgboost_tuned_fda %>% \n  tune::select_best(metric = \"mn_log_loss\")\n\nxgboost_tuned_fda %>% \n  collect_metrics(summarise = TRUE) %>%\n  filter(.config == xgboost_best_params$.config)\n```\n\n\n-   Run best model\n\n```{r}\n\nxgboost_model_final <- xgboost_model %>% \n  finalize_model(xgboost_best_params)\nxgboost_model_final\n\n```\n\n```{r}\ntrain_processed <- bake(preprocessing_recipe,  new_data = ml_data_fda)\nset.seed(1)\ntrained_model =  xgboost_model_final %>%\n  # fit the model on all the training data\n  fit(\n    formula = wm ~ ., \n    data    = train_processed\n  )\n```\n\n-   Check the best cuting point\n\n```{r}\ntest_cut_point= function(P_cut){\n # P_cut = 0.90 \naccuracy_df = trained_model %>% \n  predict(new_data = train_processed, type = c(\"prob\")) %>%\n  mutate(.pred_class = factor(ifelse(.pred_1>P_cut, 1, 0), levels = c(\"1\",\"0\"))) %>%\n  dplyr::select(-.pred_0,-.pred_1) %>%\n  bind_cols(ml_data_fda) %>%\n  yardstick::accuracy(truth = wm, .pred_class) %>% \n  mutate(cut_point = P_cut)\nreturn(accuracy_df)\n}\ncut_point_df = bind_rows(lapply(X = seq(0.05,0.85, by =0.01), test_cut_point)) \n\nmax_accuracy_point = cut_point_df %>% \n  filter(.estimate == max(.estimate))\nmax_accuracy_point\n```\n\n```{r}\ncut_point_df%>% \n  ggplot(aes(cut_point, .estimate))+\n  geom_line()+\n  geom_vline(xintercept = max_accuracy_point$cut_point[1])\n```\n\n```{r}\n# predict for the training data\ntrain_prediction1 <- trained_model %>% \n  predict(new_data = train_processed, type = c(\"prob\")) %>%\n  # mutate(.pred_class = as.factor(ifelse(.pred_1>max_accuracy_point$cut_point[1], 1, 0))) %>%\n    mutate(.pred_class = factor(ifelse(.pred_1>max_accuracy_point$cut_point[1], 1, 0), levels = c(\"1\",\"0\"))) %>%\n\n  dplyr::select(-.pred_0,-.pred_1) %>%\n  bind_cols(ml_data_fda)\n\nxgboost_score_train1 <- train_prediction1 %>%\n  yardstick::metrics(truth = wm, .pred_class, options = list(accuracy(), kap(), roc_auc())) #%>%\n  # mutate(.estimate = format(round(.estimate, 2), big.mark = \",\"))\nxgboost_score_train1\n# trained_model$spec\n\n```\n\n#### .Confusion matrix\n\n```{r}\ntrain_prediction1 %>% \n  conf_mat(wm, .pred_class) %>% \n  autoplot(type = \"heatmap\")\n\n# train_prediction1 %>% \n  \n```\n\n#### .Roc curve\n\n```{r}\ntrain_prediction2 <- trained_model %>% \n  predict(new_data = train_processed, type = c(\"prob\")) %>%\n  bind_cols(ml_data_fda)\n\ntrain_prediction2 %>% \n  roc_curve(wm, .pred_1) %>% \n  autoplot()\n```\n\n#### .metrics\n\n```{r}\nbind_rows(\n  xgboost_score_train1,\ntrain_prediction1 %>% \n  sens(wm, .pred_class),\ntrain_prediction1 %>% \n  spec(wm, .pred_class),\ntrain_prediction1 %>% \n  precision(wm, .pred_class),\ntrain_prediction2 %>% \n  roc_auc(wm, .pred_1),\ntrain_prediction2 %>% \n  mn_log_loss(wm, .pred_1)\n)\n\n# recall, precision, f_meas,accuracy, kap,roc_auc, sens, spec\n\n```\n\n```{r}\ntrained_model2 = trained_model\n# aaaa$data %>% \nxx = trained_model$fit$feature_names\ntrained_model2$fit$feature_names = str_replace(str_replace(xx , \"`\", \"\"), \"`\", \"\")\n# trained_model2$fit$feature_names\n```\n\n### Relative importance\n\n```{r}\n\naaaa = trained_model2 %>% \n  vip(geom = \"col\", num_features = 30)\n\nvip_fda = aaaa$data %>% \n  mutate(Variable = str_replace(Variable, \"`\", \"\"),\n         Variable = str_replace(Variable, \"`\", \"\"))\n\nas.data.frame(vip_fda) %>% \n  arrange(-Importance) %>%\n  mutate(nr = 1:nrow(vip_fda)) %>% \n  filter(nr <= 10) %>% \n  summarise(sum(Importance))\n\n\nvar_names12 = vip_fda[1:9,]$Variable\n```\n\n```{r}\naaaa$data %>% \n  mutate(Variable = case_when(Variable == \"theta_r\" ~ \"Residual soil water content\",\n                              Variable == \"theta_s\" ~ \"Saturated soil water content\",\n                              Variable == \"om\" ~ \"Soil organic matter\",\n                              Variable == \"ph\" ~ \"Soil pH\",\n                              Variable == \"bd\" ~ \"Soil bulk density\",\n                              Variable == \"log_sand_clay\" ~ \"log(Sand/Clay)\",\n                              # Variable == \"clay\" ~ \"Clay\",\n                              Variable == \"log_silt_clay\" ~ \"log(Silt/Clay)\",\n                              Variable == \"elevation\" ~ \"Elevation\",\n                              TRUE ~ Variable)) %>% \n  arrange(-Importance)  %>%\n  mutate(nr = 1:nrow(vip_fda)) %>% \n  # filter(nr <= 20) %>%\n  mutate(Variable = str_replace(Variable, \"  \", \" \")) %>% \n  ggplot(aes(Importance*100, reorder(Variable,Importance), fill =Importance))+\n  geom_errorbar(aes(xmin = 0, xmax = Importance*100), width = 0)+\n  geom_point(size = 3, shape =21)+\n  scale_fill_viridis_c()+\n  scale_color_viridis_c()+\n  theme(legend.position = \"none\")+\n  labs(x = \"Relative importance (%)\",\n       y = \"\" )\n# ggsave(\"figs/xboost_figs/importance_fda.png\", width = 6,height =6, bg = \"white\")\n\n  \n\n```\n\n### Centered ICE curves\n\n[about ice curve](https://christophm.github.io/interpretable-ml-book/ice.html)\n\n```{r}\ninfluence_plot = function(var){\n\nif(var == \"om\"){\n  var1 = \"Soil organic matter\" \n}else if(var == \"theta_r\"){\n    var1 = \"Residual soil water content\"\n    }else if(var ==\"log_silt_clay\" ){\n      var1 = \"log(Silt/Clay)\"\n  }else{var1 = var}  \n  \nplot_i = pdp::partial(trained_model2$fit,\n             pred.var = var,#var[i],\n             train =  subset(ml_data_fda, select = -wm),\n             type = \"classification\",\n             which.class =1L,\n             plot = TRUE,\n             prob =T,\n             alpha = 1,\n             plot.engine = \"ggplot2\")+\n  geom_smooth(se = F, color = \"darkred\", method = \"gam\", formula = y ~ s(x, bs = \"cs\"))+\n  labs(y = \"Probability\",\n       x = paste(var1))\n\nreturn(plot_i)\n}\n\n```\n\n```{r fig.height=8, fig.width=10, message=FALSE, warning=FALSE}\ndo.call(patchwork::wrap_plots, lapply(var_names12[1:9],influence_plot))+\n  plot_layout(ncol = 3)+\n  plot_annotation(tag_levels = \"A\")\n# ggsave(\"figs/xboost_figs/partial_fda.png\", width = 9,height =8, bg = \"white\")\n```\n\n### SHAP values\n\n-   Finalize workflow\n\n```{r}\n\nsplit_data = make_splits(ml_data_fda,\n            assessment = ml_data_fda)\n\nregisterDoParallel(cores = 1)\n\nset.seed(1)\nfinal_xgb <- finalize_workflow( xgboost_wf, xgboost_best_params) %>% \n  last_fit(split_data, \n           metrics = metric_set(accuracy, roc_auc, mn_log_loss, pr_auc, f_meas, precision, recall))\nfinal_xgb$.metrics\n\n```\n\n\nUseful sources : [link 1](https://juliasilge.com/blog/xgboost-tune-volleyball/) and [link 2](https://liuyanguu.github.io/post/2019/07/18/visualization-of-shap-for-xgboost/)\n\n```{r}\nset.seed(1)\nfitted_data <- preprocessing_recipe %>%\n  prep() %>%\n  bake(new_data = ml_data_fda) %>%\n  dplyr::select(-wm)\n# set.seed(1)\nxgb_model_extrac = extract_fit_engine(final_xgb)\nshap_data = fitted_data %>% as.matrix()\ncolnames(shap_data) = xgb_model_extrac$feature_names\n# set.seed(1)\nshap_long = shap.prep(xgb_model = extract_fit_engine(final_xgb),\n                      X_train = shap_data)\n# set.seed(1)\nshap_values = shap.values(xgb_model = extract_fit_engine(final_xgb),\n                      X_train = shap_data)\n\n#plot\nshap.plot.summary(data_long = shap_long,\n                  scientific = F)\n\n\n\n```\n\n```{r}\nshap_long_tidy = shap_long %>% \n  mutate(variable = as.character(variable)) %>% \n  mutate(variable = case_when(variable == \"theta_r\" ~ \"Residual soil water content\",\n                              variable == \"theta_s\" ~ \"Saturated soil water content\",\n                              variable == \"om\" ~ \"Soil organic matter\",\n                              variable == \"ph\" ~ \"Soil pH\",\n                              variable == \"bd\" ~ \"Soil bulk density\",\n                              variable == \"log_sand_clay\" ~ \"log(Sand/Clay)\",\n                              # Variable == \"clay\" ~ \"Clay\",\n                              variable == \"log_silt_clay\" ~ \"log(Silt/Clay)\",\n                              variable == \"elevation\" ~ \"Elevation\",\n                              TRUE ~ variable)) %>% \n  mutate(variable = str_replace(variable, \"`\", \"\"),\n         variable = str_replace(variable, \"`\", \"\"),\n         variable = str_replace(variable, \"  \", \" \")) %>% \n  mutate(variable= as.factor(variable))\n```\n\n#### SHAP summary plot\n\n```{r fig.height=6, fig.width=8}\n#graph1\nshap_long_tidy %>% \n  ggplot(aes(mean_value,reorder(variable, mean_value), color = mean_value))+\n  geom_errorbar(aes(xmin = 0, xmax = mean_value),\n                width = 0)+\n  geom_point( size= 2)+\n  scale_color_gradient(low =\"#1e88e5ff\", high = \"#ff0d57ff\",limits =c(0,1),\n                       breaks = c(0, 1), labels = c(\" Low\", \"High \"))+\n  background_grid(major = c(\"y\"), size.major = 0.2)+\n  labs(x = \"Mean(|SHAP value|)\",\n       y =\"\",\n       color = 'Predictor value',\n       subtitle = \"Global predictor importance\")+\n  # scale_x_continuous(limits =c(0,0.5))+\n  \n  \n#graph2\nshap_long_tidy %>% \n  mutate(variable = str_replace(variable, \"`\", \"\"),\n         variable = str_replace(variable, \"`\", \"\")) %>% \n  ggplot(aes(value, reorder(variable, mean_value), color = stdfvalue))+\n  geom_vline(xintercept = 0, linetype =2) +\n  geom_jitter(height = 0.2)+\n  scale_color_gradient(low =\"#1e88e5ff\", high = \"#ff0d57ff\",limits =c(0,1),\n                       breaks = c(0, 1), labels = c(\" Low\", \"High \"))+\n  labs(x = \"SHAP value (impact on model output)\",\n       y = \"\",\n       color = 'Predictor value',\n       subtitle = \"Local explanation summary\")+\n  scale_x_continuous(breaks = seq(-3, 3,0.5 ))+\n  background_grid(major = c(\"y\"), size.major = 0.2)+\n  theme(axis.text.y = element_blank(),\n        axis.line.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        plot.subtitle = element_text(hjust = 0.6))+\n  \n  #patchwork\n  \n  plot_layout(guides = \"collect\",widths = c(1,1.5) )+\n  plot_annotation(tag_levels = \"A\")\n  \nggsave(\"figs/xboost_figs/SHAP_values.png\",height = 6, width = 12, dpi=600, bg = \"white\")\n```\n\n#### SHAP Dependence plots\n\n```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=12}\n# do.call(patchwork::wrap_plots, lapply(var_names12[1:9],influence_plot))+\nshap_vars =  as.character(unique(shap_long_tidy$variable))\n\n\ndo.call(patchwork::wrap_plots,\n        lapply(1:10, \n               function(i){\n                 shap.plot.dependence(data_long = shap_long_tidy,\n                                      x = shap_vars[i],\n                                      smooth = F,\n                                      color_feature = \"auto\")+\n                   geom_smooth(se = F,\n                               color = \"black\",\n                               method = \"gam\",\n                               formula = y ~ s(x, bs = \"cs\", k = 15))+\n                   theme_half_open(font_size = 10)+\n                   scale_color_gradient(low =\"#1e88e5ff\",\n                                        high = \"#ff0d57ff\",\n                                        n.breaks = 5,\n                                        guide = guide_colorbar(barwidth = 5,\n                                                               barheight = 0.3))+\n                   labs(title = paste(shap_vars[i]),\n                        y = paste0(\"SHAP value for\\n\", shap_vars[i]))+\n                   scale_x_continuous(n.breaks = 6)+\n                   theme(legend.position = \"top\",\n                         legend.text = element_text(size=5, angle = 25),\n                         legend.title = element_text(size=7))\n                 }\n               )\n)+\n  plot_layout(ncol = 2)+\n  plot_annotation(tag_levels = \"A\")\nggsave(\"figs/xboost_figs/shap_dependence.png\", dpi = 900, height = 11, width = 7,bg=\"white\")\n\n```\n\n\n```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=12}\n\ndo.call(patchwork::wrap_plots,\n        lapply(11:length(shap_vars), \n               function(i){\n                 shap.plot.dependence(data_long = shap_long_tidy,\n                                      x = shap_vars[i],\n                                      smooth = F,\n                                      color_feature = \"auto\")+\n                   geom_smooth(se = F,\n                               color = \"black\",\n                               method = \"gam\",\n                               formula = y ~ s(x, bs = \"cs\", k = 15))+\n                   theme_half_open(font_size = 10)+\n                   scale_color_gradient(low =\"#1e88e5ff\",\n                                        high = \"#ff0d57ff\",\n                                        n.breaks = 5,\n                                        guide = guide_colorbar(barwidth = 5,\n                                                               barheight = 0.3))+\n                   labs(title = paste(shap_vars[i]),\n                        y = paste0(\"SHAP value for\\n\", shap_vars[i]))+\n                   theme(legend.position = \"top\",\n                         axis.title.y = element_text(), \n                         legend.text = element_text(size=6, angle = 25),\n                         legend.title = element_text(size=7))\n                 }\n               )\n)+\n  plot_layout(ncol = 4)+\n  plot_annotation(tag_levels = \"A\")\n\nggsave(\"figs/xboost_figs/shap_dependence_remainig.png\", dpi = 600, height = 15, width = 15,bg=\"white\")\n```\n\n\n\n\n<!-- ```{r} -->\n\n<!-- plot_data <- shap.prep.stack.data(shap_contrib = shap_values$shap_score, top_n = 10, n_groups = 2) -->\n\n<!-- shap.plot.force_plot(plot_data,  -->\n\n<!--                      zoom_in_group = 2) -->\n\n<!-- ``` -->\n\n```{r include=FALSE}\nfile = \"code_boosting_white-mold_files/desktop.ini\"\nif (file.exists(file)) {\n unlink(file)\n cat(\"The file is deleted\")\n}\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"self-contained-math":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":false,"css":["styles.css"],"toc":true,"output-file":"code_boosting_white-mold.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"theme":{"light":"flatly","dark":"darkly"},"smooth-scroll":true,"title":"XgBoost model"},"extensions":{"book":{"multiFile":true}}}}}